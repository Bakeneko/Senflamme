var Fire = new function() {	var ctx;	var NODES_X = Math.ceil( window.innerWidth * 0.02 );	var	NODES_Y = Math.ceil( window.innerHeight * 0.02 );		var BEAT_VELOCITY = 0.01;	var BEAT_FREQUENCY = 1;	var BEAT_LIMIT = 10;		// Distance threshold between active node and beat	var ACTIVATION_DISTANCE = 10;		// The world dimensions	var world = { 			width: window.innerWidth, 			height: window.innerHeight,			center: new Point( window.innerWidth/2, window.innerHeight/2 )	};		var id = 0;	var container;	var currentBeat = null;	var currentStyle = null;	var currenStyleCounter = 0;		var nodes = [];	var beats = [];		/**	 * 	 */	this.initialise = function() {			ctx = Sketch.create();		ctx.autopause = false;		container = document.querySelector( '#wrapper' );		container.appendChild( ctx.canvas );		currentStyle = "circle";				log('current style : ' + currentStyle);		log('beat frequency : ' + BEAT_FREQUENCY);		log('beat velocity : ' + BEAT_VELOCITY);		ctx.setup = function() {			// Distance between nodes			var cx = world.width / ( NODES_X + 1 ),				cy = world.height / ( NODES_Y + 1 );			var i,				j,				x = 0,				y = 0;			// Generate nodes						var color1 = 'rgba(244, 123, 32, 1)';			var color2 = 'rgba(230, 57, 37, 1)';			var color3 = 'rgba(235, 76, 36, 1)';			var color4 = 'rgba(242, 98, 34, 1)';			var color5 = 'rgba(247, 149, 58, 1)';						var startX = world.center.x;			var startY = world.center.y + 14/2*cy;						//line 1			nodes.push(new Node(startX-cx*1, startY, color1, true));			nodes.push(new Node(startX+cx*1, startY, color1, true));			//line 2			nodes.push(new Node(startX-cx*1, startY-cy*1, color1, true));			nodes.push(new Node(startX-cx*2, startY-cy*1, color1, true));			nodes.push(new Node(startX-cx*3, startY-cy*1, color1, true));			nodes.push(new Node(startX+cx*2, startY-cy*1, color1, true));			nodes.push(new Node(startX+cx*1, startY-cy*1, color1, true));			//line 3			nodes.push(new Node(startX-cx*1, startY-cy*2, color2, true));			nodes.push(new Node(startX-cx*2, startY-cy*2, color2, true));			nodes.push(new Node(startX-cx*3, startY-cy*2, color2, true));			nodes.push(new Node(startX-cx*4, startY-cy*2, color3, true));			nodes.push(new Node(startX+cx*3, startY-cy*2, color1, true));			nodes.push(new Node(startX+cx*2, startY-cy*2, color1, true));			nodes.push(new Node(startX+cx*1, startY-cy*2, color3, true));			//line 4			nodes.push(new Node(startX-cx*1, startY-cy*3, color2, true));			nodes.push(new Node(startX-cx*2, startY-cy*3, color2, true));			nodes.push(new Node(startX-cx*3, startY-cy*3, color2, true));			nodes.push(new Node(startX-cx*4, startY-cy*3, color3, true));			nodes.push(new Node(startX-cx*5, startY-cy*3, color3, true));			nodes.push(new Node(startX+cx*4, startY-cy*3, color1, true));			nodes.push(new Node(startX+cx*3, startY-cy*3, color1, true));			nodes.push(new Node(startX+cx*2, startY-cy*3, color3, true));			nodes.push(new Node(startX+cx*1, startY-cy*3, color2, true));			//line 5			nodes.push(new Node(startX, startY-cy*4, color2, true));			nodes.push(new Node(startX-cx*2, startY-cy*4, color2, true));			nodes.push(new Node(startX-cx*3, startY-cy*4, color3, true));			nodes.push(new Node(startX-cx*4, startY-cy*4, color3, true));			nodes.push(new Node(startX-cx*5, startY-cy*4, color3, true));			nodes.push(new Node(startX+cx*4, startY-cy*4, color1, true));			nodes.push(new Node(startX+cx*3, startY-cy*4, color1, true));			nodes.push(new Node(startX+cx*2, startY-cy*4, color2, true));			nodes.push(new Node(startX+cx*1, startY-cy*4, color2, true));			//line 6			nodes.push(new Node(startX, startY-cy*5, color2, true));			nodes.push(new Node(startX-cx*1, startY-cy*5, color2, true));			nodes.push(new Node(startX-cx*3, startY-cy*5, color3, true));			nodes.push(new Node(startX-cx*4, startY-cy*5, color4, true));			nodes.push(new Node(startX-cx*5, startY-cy*5, color4, true));			nodes.push(new Node(startX+cx*4, startY-cy*5, color1, true));			nodes.push(new Node(startX+cx*3, startY-cy*5, color2, true));			nodes.push(new Node(startX+cx*2, startY-cy*5, color2, true));			nodes.push(new Node(startX+cx*1, startY-cy*5, color2, true));			//line 7			nodes.push(new Node(startX, startY-cy*6, color2, true));			nodes.push(new Node(startX-cx*1, startY-cy*6, color3, true));			nodes.push(new Node(startX-cx*2, startY-cy*6, color3, true));			nodes.push(new Node(startX-cx*4, startY-cy*6, color4, true));			nodes.push(new Node(startX-cx*5, startY-cy*6, color4, true));			nodes.push(new Node(startX+cx*4, startY-cy*6, color2, true));			nodes.push(new Node(startX+cx*3, startY-cy*6, color2, true));			nodes.push(new Node(startX+cx*2, startY-cy*6, color2, true));			nodes.push(new Node(startX+cx*1, startY-cy*6, color2, true));			//line 8			nodes.push(new Node(startX, startY-cy*7, color3, true));			nodes.push(new Node(startX-cx*1, startY-cy*7, color3, true));			nodes.push(new Node(startX-cx*2, startY-cy*7, color3, true));			nodes.push(new Node(startX-cx*3, startY-cy*7, color3, true));			nodes.push(new Node(startX-cx*5, startY-cy*7, color4, true));			nodes.push(new Node(startX+cx*3, startY-cy*7, color2, true));			nodes.push(new Node(startX+cx*2, startY-cy*7, color2, true));			nodes.push(new Node(startX+cx*1, startY-cy*7, color2, true));			//line 9			nodes.push(new Node(startX, startY-cy*8, color3, true));			nodes.push(new Node(startX-cx*1, startY-cy*8, color3, true));			nodes.push(new Node(startX-cx*2, startY-cy*8, color3, true));			nodes.push(new Node(startX-cx*3, startY-cy*8, color3, true));			nodes.push(new Node(startX-cx*4, startY-cy*8, color4, true));			nodes.push(new Node(startX+cx*2, startY-cy*8, color2, true));			nodes.push(new Node(startX+cx*1, startY-cy*8, color2, true));			//line 10			nodes.push(new Node(startX, startY-cy*9, color3, true));			nodes.push(new Node(startX-cx*1, startY-cy*9, color3, true));			nodes.push(new Node(startX-cx*2, startY-cy*9, color4, true));			nodes.push(new Node(startX-cx*3, startY-cy*9, color4, true));			nodes.push(new Node(startX-cx*4, startY-cy*9, color4, true));			nodes.push(new Node(startX+cx*1, startY-cy*9, color3, true));			//line 11			nodes.push(new Node(startX, startY-cy*10, color3, true));			nodes.push(new Node(startX-cx*1, startY-cy*10, color4, true));			nodes.push(new Node(startX-cx*2, startY-cy*10, color4, true));			nodes.push(new Node(startX-cx*3, startY-cy*10, color4, true));			//line 12			nodes.push(new Node(startX, startY-cy*11, color4, true));			nodes.push(new Node(startX-cx*1, startY-cy*11, color5, true));			nodes.push(new Node(startX-cx*2, startY-cy*11, color5, true));			//line 13			nodes.push(new Node(startX, startY-cy*12, color5, true));			nodes.push(new Node(startX-cx*1, startY-cy*12, color5, true));			//line 14			nodes.push(new Node(startX, startY-cy*13, color5, true));						// Generate beats			for( i = 0; i < BEAT_LIMIT; i++ ) {				var beat = new Beat( 					startX,					startY,					i				);				beats.push( beat );			}		};		ctx.draw = function() {			// Render nodes			for( var i = 0; i < nodes.length; i++ ) {				var node = nodes[i];				this.updateNode( node );				this.drawNode( node );			}			// Render beats			ctx.save();			var activeBeats = 0;			for( var i = 0; i < beats.length; i++ ) {				var beat = beats[i];				this.updateBeat( beat );				if( beat.active ) activeBeats ++;			}			ctx.restore();			var nextBeat = currentBeat ? beats[ ( currentBeat.index + 1 ) % beats.length ] : null;			if( !currentBeat ) {				currentBeat = beats[0];				currentBeat.activate();			}			else if( !nextBeat.active && activeBeats < BEAT_FREQUENCY && currentBeat.strength > 1 / BEAT_FREQUENCY ) {				currentBeat = nextBeat;				currentBeat.activate();			}		};		ctx.updateNode = function( node ) {			node.size += ( node.sizeTarget - node.size ) * 0.05;			if( node.growing ) {				node.strength = Math.min( node.strength + 0.15, 1 );			}			else {				node.strength = Math.max( node.strength - 0.02, 0 );			}			if( node.strength >= 1 ) {				node.growing = false;			}			node.offsetTargetX *= 0.6;			node.offsetTargetY *= 0.6;			node.offsetX += ( node.offsetTargetX - node.offsetX ) * 0.2;			node.offsetY += ( node.offsetTargetY - node.offsetY ) * 0.2;		};		ctx.drawNode = function( node ) {			// Angle and distance between node and center			var radians = Math.atan2( world.center.y - node.y, world.center.x - node.x ),				distance = node.distanceTo( world.center.x, world.center.y );			var distanceFactor = distance / Math.min( world.width, world.height );			// Offset for the pin head			var ox = node.offsetX + Math.cos( radians - Math.PI ) * ( 30 * distanceFactor ) * node.strength,				oy = node.offsetY + Math.sin( radians - Math.PI ) * ( 30 * distanceFactor ) * node.strength;			if( currentStyle === 'circle' ) {				if( node.active ) {					ctx.beginPath();					ctx.arc( node.paintedX, node.paintedY, node.size * 25 * ( 0.1 + node.strength ), 0, Math.PI * 2, true );					ctx.fillStyle = node.color;					ctx.fill();					node.size = 1;				}				else {					node.size = node.sizeTarget || 1;				}			}			else if( currentStyle === 'square' ) {				ctx.moveTo( node.paintedX, node.paintedY );				ctx.beginPath();				var size = node.size * 25 * ( 0.1 + node.strength );				ctx.lineTo( node.paintedX-size, node.paintedY -size);				ctx.lineTo( node.paintedX+size, node.paintedY -size);				ctx.lineTo( node.paintedX+size, node.paintedY +size);				ctx.lineTo( node.paintedX-size, node.paintedY +size);				ctx.fillStyle = node.color;				ctx.fill();				node.size = node.sizeTarget || 1;			}			else {				node.size = node.sizeTarget || 2;			}			node.paintedX = node.x + ox;			node.paintedY = node.y + oy;			// Pin head			ctx.beginPath();			ctx.arc( node.paintedX, node.paintedY, node.size, 0, Math.PI * 2, true );			ctx.fillStyle = node.color;			ctx.fill();		};		ctx.updateBeat = function( beat ) {			if( beat.active ) {				beat.strength += BEAT_VELOCITY;			}			// Remove used up beats			if( beat.strength > 1 ) {				beat.deactivate();			}			else if( beat.active ) {				// Check for collision with nodes				for( var j = 0; j < nodes.length; j++ ) {					var node = nodes[j];					if( node.active && node.collisionLevel < beat.level ) {						// Distance between the beat wave and node						var distance = node.distanceTo( beat.x, beat.y ) - ( beat.size * beat.strength );						distance = distance >= 0 ? distance : 0;						if( distance < ACTIVATION_DISTANCE ) {							node.collisionLevel = beat.level;							node.highlight();						}					}				}			}		};		ctx.keydown = function( event ) {			if( event.keyCode == 82 ) { //R				/*				for( var i = 0;i < nodes.length; i++ ) {					nodes[i].deactivate();				}				*/			}			else if( event.keyCode == 70 ) { //F				BEAT_FREQUENCY++;				if(BEAT_FREQUENCY > 5)					BEAT_FREQUENCY = 1;				log('beat frequency : ' + BEAT_FREQUENCY);			}			else if( event.keyCode == 86 ) { //V				BEAT_VELOCITY+=0.005;				if(BEAT_VELOCITY > 0.05)					BEAT_VELOCITY = 0.005;				log('beat velocity : ' + BEAT_VELOCITY);			}			else if( event.keyCode == 83 ) { //S				currenStyleCounter++;				if(currenStyleCounter > 2)					currenStyleCounter = 0;				if(currenStyleCounter == 0)					currentStyle = "circle";				else if(currenStyleCounter == 1)					currentStyle = "square";				else if(currenStyleCounter == 2)					currentStyle = "none";				log('current style : ' + currentStyle);			}		};	};	function getNodeByIndex( h, v ) {		if( h >= NODES_X || h < 0 || v >= NODES_Y || v < 0 ) return null;		return nodes[ ( v * NODES_X ) + h ];	}			/**	 * Represets one node/point in the grid.	 */	function Node( x, y, color, active ) {		// invoke super		this.constructor.apply( this, arguments );		this.id = ++id;		this.collisionLevel = 0;		this.active = active;		this.growing = false;		this.strength = 0;		this.size = 0;		this.sizeTarget = this.size;		this.offsetX = 0;		this.offsetY = 0;		this.offsetTargetX = 0;		this.offsetTargetY = 0;		this.paintedX = this.x;		this.paintedY = this.y;		this.color = color;	}	Node.prototype = new Point();	Node.prototype.distanceTo = function( x, y ) {		var dx = x - this.paintedX;		var dy = y - this.paintedY;		return Math.sqrt(dx*dx + dy*dy);	};	Node.prototype.activate = function() {		this.active = true;		this.sizeTarget = 5;	};	Node.prototype.deactivate = function() {		this.active = false;		this.sizeTarget = 1;	};	Node.prototype.reset = function() {		this.collisionLevel = 0;		this.growing = false;		this.strength = 0;		this.size = 0;		this.sizeTarget = this.size;		this.offsetX = 0;		this.offsetY = 0;		this.offsetTargetX = 0;		this.offsetTargetY = 0;		this.paintedX = this.x;		this.paintedY = this.y;	};	Node.prototype.highlight = function( delay ) {		this.growing = true;	};	/**	 * Represents a beatwave that triggers nodes.	 */	function Beat( x, y, index ) {		// invoke super		this.constructor.apply( this, arguments );		this.color = 'hsla(180, 100%, 100%, 0.2)';		this.index = index;		this.level = ++id;		this.size = Math.max( world.width, world.height );		this.active = false;		this.strength = 0;	};	Beat.prototype = new Point();	Beat.prototype.activate = function() {		this.level = ++id;		this.active = true;		this.strength = 0;	};	Beat.prototype.deactivate = function() {		this.active = false;	};};function log(){	window.console.log.history = window.console.log.history || [];	window.console.log.history.push(arguments);	if(window.console)	{		if (arguments.length == 1 && window.console.debug)			window.console.debug(arguments[0]);		else			window.console.log(Array.prototype.slice.call(arguments));	}}Fire.initialise();